MGHD/HyperBlossom — Progress Log

2025-08-28 13:30 UTC

- Added tools/cudaq_sampler.py: lazy CUDA-Q facade with numpy fallback, exposes CudaqGarnetSampler.sample_batch() and get_code_mats().
- Added tools/relay_teacher.py: LUT-based relay teacher (mwpf/mwpm) with CLI and Python API; strict packed-syndrome I/O.
- Added tools/eval_ler.py: coset-aware LER harness with Wilson CIs, latency estimates, decoder matrix including mghd/fastpath/relay.
- Wired Step-11 training into unified_mghd_optimizer.py: --step11-train path, streaming sampler, bf16 AMP, cosine warmup, best-ckpt save, auto-eval.
- Kept CUDA usage under callables; no CUDA work at import time.

Next steps
- Integrate true CUDA-Q kernels (foundation/student) behind sampler when available.
- Expand MWPM baseline beyond LUT proxy when geometry is ready.
- Add FLOPs estimator for MGHD (attention + GNN) for reporting.

2025-08-28 13:39 UTC (cleanup + pre-flight)

Environment: All commands are run within `conda activate mlqec-env`.

2025-08-28 14:20 UTC (Step‑11 long run + latency)

- Launched Step‑11 (S profile) long training in background:
  `python unified_mghd_optimizer.py --step11-train --profile S --garnet-mode foundation --teacher-ensemble mwpf+mwpm --epochs 20 --steps-per-epoch 800 --batch-size 512 --lr 1e-4 --weight-decay 1e-4 --grad-clip 1.0 --compile --amp bf16 --outdir results/step11 --seed 42 > results/step11/train_S.log 2>&1 &`
- GPU: NVIDIA H100 NVL (cc 9.0). CUDA available.
- Batch‑1 latency (dryrun S checkpoint, eager): p50≈5.34 ms, p99≈8.72 ms on H100. Script used decode_one for 1000 runs with 200 warmup.

2025-08-28 16:05 UTC (S results, launch L, latency compare)

- Training S completed: best val LER≈0.3359; LER JSON written with p-grid (0.02..0.08) and ~2.55 ms p50 per-shot latency measured in harness.
- Launched Step‑11 (L profile) training in background:
  `python unified_mghd_optimizer.py --step11-train --profile L --garnet-mode foundation --teacher-ensemble mwpf+mwpm --epochs 20 --steps-per-epoch 800 --batch-size 512 --lr 1e-4 --weight-decay 1e-4 --grad-clip 1.0 --compile --amp bf16 --outdir results/step11_L --seed 42 > results/step11_L/train_L.log 2>&1 &`
- Batch‑1 latency (H100, eager, 1000 reps, 200 warmup):
  - S checkpoint (final): p50≈2.68 ms, p99≈5.60 ms, mean≈2.76 ms
  - L architecture (untrained proxy): p50≈3.40 ms, p99≈9.15 ms, mean≈4.38 ms
  These are architectural latencies; final trained L should be similar.

2025-08-28 16:30 UTC (Policy + Agents guide)

- Teacher policy locked: MWPF primary, MWPM fallback; ensemble tie‑break by minimum weight under strict parity/coset checks.
- Foundation deltas: ±10% around Garnet calibration parameters in `cudaq_backend/garnet_noise.py`.
- Added developer guide: `Agents.md` (project mission, environment, data conventions, teachers, Garnet noise, training flows, evaluation, latency optimization, coding rules, playbooks).

2025-08-28 16:45 UTC (Plan: CUDA‑Q + MWPF teacher + domain randomization)

- CUDA‑Q only: All data is generated by CUDA‑Q circuit‑level simulation for rotated d=3. No non‑CUDA‑Q sampling is permitted.
- Teacher integration: MWPF 0.2.12 primary, PyMatching 2.0.1 fallback; if both succeed, select the lower‑weight valid correction under strict parity/coset checks. We will use Stim DEM strictly as decoder metadata (never for sampling) and attach it via `SinterMWPFDecoder.with_circuit(circuit)` so MWPF sees heralded/circuit‑level structure.
- Garnet foundation domain randomization (device‑agnostic):
  - 1Q infidelity p1 ~ log‑uniform [1e‑4, 5e‑3]; per‑epoch drift ×U[0.97,1.03]
  - 2Q infidelity p2 ~ log‑uniform [3e‑3, 3e‑2] with bad‑edge tail f_bad~U[0.05,0.20], κ~U[3,8], clip to 0.12; per‑epoch drift ×U[0.95,1.05]
  - T1_us ~ log‑uniform [20,150], T2_us ~ log‑uniform [2,80], enforce T2 ≤ 0.7·T1; derive Tφ for idle windows
  - Durations t_prx_ns~U[20,80], t_cz_ns~U[25,120], optional t_meas_ns~U[300,800]
  - Readout asymmetry: e~U[0.01,0.05], r~LogNormal(0,0.35) → eps0=clip(e/r,[0.002,0.10]), eps1=clip(e·r,[0.002,0.10])
  - Crosstalk proxy α_xtalk~U[1.1,1.5] during CZ on neighbors; spatial heterogeneity ±5–10% over p1, p2, eps0, eps1 with at least one bad edge per patch; regime mix [0.6,0.3,0.1] × [1.0,1.5,2.5]
- Baseline vs MGHD (small run) before scale: adapt `poc_gnn_train.py` to consume the CUDA‑Q Garnet dataset (same split for both models) and recreate LER curves; proceed only if MGHD ≥ baseline.
- S/M/L + Optuna (LER‑first): quick retest then Optuna sweeps minimizing LER (latency as a constraint) to select best profile.
- Latency (B=1) policy: keep CUDA Graph for decode_one (preallocated buffers) because it is fastest; keep TS/TRT/ONNX only if they improve measured latency further.
- Post‑student pipeline: distillation → QAT (FP16→INT8) → structured pruning (channels/heads by LER contribution) → TensorRT/ONNX engines for sub‑µs single‑shot, with zero tolerance for LER or latency regression.

2025-08-28 19:28 UTC (Baseline vs MGHD small run complete)

- Dataset: rotated d=3, CUDA‑Q Garnet foundation (MWPF primary, MWPM fallback), B≈20k.
- Training: 5 epochs, batch size 128, full epoch (125 steps/epoch).
- Result: Baseline GNN best LER=0.3586; MGHD best LER=0.3586 (tied). Artifacts written under `Plots and Data/` with run ID `MGHD_vs_Baseline_d3_panqec_YYYYMMDD_HHMMSS`.
- Action: scale to longer run and Optuna sweeps; improve MGHD > baseline before scheduling large foundation/student.

2025-08-28 19:30 UTC (Baseline vs MGHD long run started)

- Launched 30‑epoch baseline vs MGHD comparison on the same dataset to stabilize curves: `results/baseline_vs_mghd_e30.log` (PID recorded in shell). Will summarize LER curves and plots on completion.

- Pre-flight: Verified LUT present at `fastpath/rotated_d3_lut_256.npz`.
- Tests: Could not run pytest-based fastpath tests (pytest not installed on host). Parity checks remain available via tools/tests once pytest is installed.
- Cleanup: Removed 2258 zero-byte files and 136 empty directories across scratchpad (placeholders, deep dataset stubs, empty scripts). All remaining zero-byte files count = 0.
- Repo tidiness: Re-ran empty-dir pruning to collapse cascaded empties.
2025-08-28 20:35 UTC (Relaunch pack-mode 30-epoch comparison)

- Fixed pack-mode evaluator crash (baseline GNN lacked MGHD graph buffers). Evaluator now builds rotated d=3 edges from Hx/Hz for baseline and uses MGHD buffers for MGHD. Parity-based evaluation on canonical pack is consistent with training.
- Relaunching 30-epoch pack-mode baseline vs MGHD: results/baseline_vs_mghd_pack_e30.log. Will report best LERs and plots on completion.

2025-08-29 01:20 UTC (Fix constant LER; AMP/GradScaler & diagnostics)

- Patched poc_gnn_train.py to make AMP/GradScaler GPU-only and added a no-op scaler on CPU. Guarded autocast to enable only when `device.type == 'cuda'` and added a safe `unscale_` call. This prevents silent no-op optimizer steps that kept weights frozen and LER constant across epochs.
- Added per-epoch parameter L2 diagnostics for both baseline GNN and MGHD to verify weights change (Δ||W||2 logs).
- Mirrored the same AMP/autocast/scaler fixes in unified_mghd_optimizer.py for both the Optuna search path and the final training path, retaining the already-correct Step‑11 section.
- Next: run a short 2–3 epoch sanity pass to confirm LER now varies epoch-to-epoch and deltas are non-zero; then resume longer runs.

2025-08-29 01:26 UTC (Non-pack rotated alignment + sanity run)

- Enforced rotated d=3 graph indices for MGHD in non-pack training while preserving a 4‑class head to match legacy CE targets; fixes node-count mismatch (17 vs 25) and CE class bound asserts.
- Verified end-to-end training runs on H100 with 1 epoch (no cap): grad norms printed; per‑epoch evaluation executed; metrics + CSV/NPY artifacts saved under `Plots and Data/`.

2025-08-29 01:35 UTC (Naming: Step‑11 -> Foundation Training)

 - Renamed preferred training entry to “Foundation Training” for clarity. Added `--foundation-train` CLI to `unified_mghd_optimizer.py`; kept `--step11-train` as a deprecated alias. Console logs now print `[Foundation]` epoch lines.
 - Updated `Agents.md` to reflect new naming and CLI; process unchanged (CUDA‑Q syndromes, MWPF primary, MWPM fallback, bf16 AMP, cosine warmup, best‑ckpt save, auto‑eval).

2025-08-29 02:15 UTC (Paper-ready artifacts in foundation trainer)

- Added run manifest and metrics capture to `unified_mghd_optimizer.py --foundation-train`:
  - Writes `cmd.txt`, `args.json`, and `env.json` in the run outdir.
  - Appends per‑epoch CSV metrics (`metrics.csv`): epoch, train_loss_mean, val_ler, samples_epoch, mwpf_shots_cum, mwpm_shots_cum.
  - Saves `teacher_stats.json` summarizing MWPF/MWPM usage.
- Updated `tools/cudaq_sampler.py` to accumulate teacher usage stats (mwpf_shots, mwpm_shots, total_shots) and expose `stats_snapshot()`.
- These artifacts support plotting and paper figures without re-running training.

2025-08-29 03:25 UTC (L profile — MWPF smoke test on H100)

- Environment check (mlqec-env):
  - cudaq 0.12.0; mwpf 0.2.12; PyMatching 2.0.1; stim 1.15.0; torch 2.7.1+cu128; CUDA available (NVIDIA H100 NVL); AMP bf16.
- Command (smoke):
  `python unified_mghd_optimizer.py --foundation-train --profile L --garnet-mode foundation --teacher-ensemble mwpf+mwpm --epochs 3 --steps-per-epoch 100 --batch-size 256 --lr 1e-4 --weight-decay 1e-4 --grad-clip 1.0 --amp bf16 --outdir results/foundation_L_mwpf_smoke --seed 42`
- Result (MWPF true labels — teacher-only stats):
  - Epoch-wise (val LER @ p≈0.05): [0.3633, 0.3350, 0.3438]; best≈0.3350.
  - Teacher usage (cumulative shots): mwpf_shots=79,872; mwpm_shots=0.
  - Artifacts: `results/foundation_L_mwpf_smoke/step11_garnet_L_best.pt`, `metrics.csv`, `env.json`, `args.json`, `teacher_stats.json`.
- Re-run (consistency): `results/foundation_L_mwpf_smoke_run2` with identical settings produced val LER ≈ [0.3750, 0.3906, 0.3984]; teacher remained MWPF-only (79,872 shots). Variability expected from short smoke duration and stochastic p-cycling.
- Note on sampling: CUDA-Q is installed and validated; current sampler path for d=3 uses the numpy fallback for syndrome generation while labels are produced via MWPF Sinter (Stim DEM). Switching sampler to `cudaq_backend.syndrome_gen.sample_surface_cudaq` is straightforward if we want strict CUDA‑Q trajectories in the training loop.
- Conclusion: Dependencies and pipeline are green; L profile can proceed to full foundation training now (recommend ≥20 epochs, steps/epoch≈800, batch=512, cosine+warmup, bf16 AMP). Monitor `metrics.csv` and auto `ler_*.json` outputs.

2025-08-29 03:30 UTC (LER-vs-epoch sanity — MWPF, longer smoke)

- Command: `--epochs 6 --steps-per-epoch 120 --batch-size 256` (MWPF labels only).
- Epoch LER@p=0.05 (validation per epoch, B=1024):
  - [0.3789, 0.3887, 0.3906, 0.3652, 0.3662, 0.3623] → trend improves after mid‑training.
- Eval harness (N=10k per p) post‑run: LER(p=0.05)=0.3644 (95% CI [0.3550, 0.3739]). File: `results/foundation_L_mwpf_smoke_run3/ler_L_foundation.json`.
- Teacher usage: mwpf_shots=190,464; mwpm_shots=0 (strict MWPF supervision).
- Takeaway: With modest training time, LER decreases after several epochs. For clearer monotonic descent, increase steps/epoch or fix train p to 0.05 to match validation.

2025-08-29 03:36 UTC (Full L foundation training — CUDA‑Q trajectories)

- Sampler switch: CudaqGarnetSampler.sample_batch now calls `cudaq_backend.syndrome_gen.sample_surface_cudaq(..., surface_layout='rotated')` when available; falls back to numpy only if CUDA‑Q path errors. Teachers remain MWPF primary via Stim DEM with strict parity/coset checks; MWPM is fallback.
- Launched full training (CUDA‑Q syndromes):
  `python unified_mghd_optimizer.py --foundation-train --profile L --garnet-mode foundation --teacher-ensemble mwpf+mwpm --epochs 20 --steps-per-epoch 800 --batch-size 512 --lr 1e-4 --weight-decay 1e-4 --grad-clip 1.0 --compile --amp bf16 --outdir results/foundation_L_cudaq --seed 42`
- PID written to `results/foundation_L_cudaq/pid.txt`; logs streaming to `results/foundation_L_cudaq/train_L_full.log`. Metrics append to `metrics.csv`; best checkpoint at `step11_garnet_L_best.pt`; final LER JSON auto-writes on completion.

2025-08-29 03:44 UTC (Stop earlier 20‑epoch run)

- Action: Stopped earlier 20‑epoch CUDA‑Q job to free GPU for 30‑epoch run.
- Killed PID from `results/foundation_L_cudaq/pid.txt` (367756) via SIGTERM; confirmed exit.
- 30‑epoch job remains active (PID in `results/foundation_L_cudaq_e30/pid.txt`).

2025-08-29 04:25 UTC (L foundation results + plots)

- Training complete: 30 epochs, 1,200 steps/epoch, batch=512; total ≈ 18.46M MWPF‑supervised shots; CUDA‑Q sampler used (`sampler_backend=cudaq_rotated_d3`).
- Best per‑epoch validation (p=0.05, N=1024): min LER≈0.1631 (early), final epochs stable ≈0.19–0.22.
- Final LER sweep (N=10k per‑p):
  - MGHD(L) mghd: p=0.02→0.1848; 0.03→0.2141; 0.05→0.2077; 0.08→0.2097 (`results/foundation_L_cudaq_e30/ler_L_foundation.json`).
  - MWPF teacher: p=0.02→0.2023; 0.03→0.1939; 0.05→0.1952; 0.08→0.2060 (`results/foundation_L_cudaq_e30/ler_mwpf.json`).
  - MWPM baseline: p=0.02→0.2158; 0.03→0.2032; 0.05→0.2025; 0.08→0.2009 (`results/foundation_L_cudaq_e30/ler_mwpm.json`).
- Plots written:
  - Training curves: `results/foundation_L_cudaq_e30/plot_training_curves.png` (val LER + loss vs epoch)
  - LER vs p (with 95% CIs): `results/foundation_L_cudaq_e30/plot_ler_vs_p.png` (MGHD vs MWPF/MWPM)
- Takeaways:
  - MGHD(L) currently does not beat MWPF/MWPM at p=0.05 (0.2077 vs 0.195–0.203). Early epoch best (0.163) did not persist as training progressed under the curriculum.
  - Throughput is excellent; optimization likely needs targeted p=0.05 focus and/or schedule/arch tweaks.

Next steps
- Fine‑tune from best checkpoint (fixed p=0.05): 10–20 epochs, steps/epoch=1200, batch=512, lower LR=5e‑5 with cosine/plateau; save best by val LER.

2025-08-29 04:27 UTC (Launched p=0.05 fine‑tune; unique outdir)

- Trainer updates: added CLI flags `--train-p`, `--val-N`, `--init-ckpt` to `unified_mghd_optimizer.py`.
  - `--train-p 0.05` fixes training p; `--val-N 4096` increases per‑epoch validation shots; `--init-ckpt` seeds from best L.
- Command:
  `python unified_mghd_optimizer.py --foundation-train --profile L --garnet-mode foundation --teacher-ensemble mwpf+mwpm --epochs 15 --steps-per-epoch 1200 --batch-size 512 --lr 5e-5 --weight-decay 1e-4 --grad-clip 1.0 --compile --amp bf16 --train-p 0.05 --val-N 4096 --init-ckpt results/foundation_L_cudaq_e30/step11_garnet_L_best.pt --outdir results/foundation_L_p005_tune_YYYYMMDD_HHMMSS --seed 42`
- Outdir: timestamped (UTC) to avoid overwriting prior runs. PID written to `pid.txt`; logs to `train_L_tune.log`; metrics to `metrics.csv`; checkpoints: `*_best.pt`, `*_last.pt`.
- Re‑evaluate with N=10k per‑p; accept only if MGHD ≤ MWPF at p=0.05.
- Optional: increase model capacity slightly (L+ variant: n_iters=10, d_model=384, msg_net=192) if latency budget allows; verify B=1 latency post‑training.
- Improve eval parity: evaluator now reconstructs model profile from `args.json` to avoid arch mismatch; consider exporting full arch config alongside checkpoints.
- Runtime estimate (30‑epoch plan):
  - Per‑step (B=512, CUDA‑Q + MWPF + FWD/BWD): ≈0.25–0.40 s
  - Per‑epoch (1,200 steps): ≈5–8 minutes
  - Total (30 epochs) ≈ 2.5–4.0 hours; final eval adds ~10–20 minutes
